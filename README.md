Eve Runner
=========================

This is a [Eve](http://python-eve.org/) project template for large application developers who intend to modularise their application by utilizing `flask.Blueprint`. 

This is a [Cookiecutter](https://cookiecutter.readthedocs.io/en/latest/) template, so to generate a project using this template use `cookiecutter`.

### Features

* Minimal setup
* Factory based application structure
* Blueprints are auto registered (yes automatically registered! see below)
* Separate configuration for development and production application
* Uses [Gunicorn](http://gunicorn.org/) for both development and production server
* Uses [Eventlet](http://eventlet.net/) worker to allow implementing asynchronous apps(i.e SocketIO by [Flask-SocketIO](https://flask-socketio.readthedocs.io))
* Only assumption made during making the template is that the developer may want to use [SQLAlchemy](https://www.sqlalchemy.org/), so [Flask-SQLAlchemy](http://flask-sqlalchemy.pocoo.org) and [Flask-Migrate](https://flask-migrate.readthedocs.io/en/latest/) are preconfigured. The developer only has to change SQLAlchemy related configurations. This can be changed or removed to use other options very easily.
* Easy `Makefile` syntax for running, testing, migrating application and it's databases.
* Auto loads SQLAlchemy models at the application startup. So no need to import all model modules by hand.
* A declarative `Base` class is prepared to suite `Eve` application structure
* [Eve SQLAlchemy](https://eve-sqlalchemy.readthedocs.io/en/latest/) is preconfigured. You only need to define the model schema for `Eve` application. See below.

### License

GPL v2

### Installation

You only need to install `cookiecutter` python package. After that run -

```
cookiecutter https://github.com/asif-mahmud/eve_runner.git
```

to create a project. 
Then open a cmd or terminal inside the newly created directory and run-

```
pip install -e . --upgrade
```

To upgrade and install your awesome application. Voila you are ready to roll.

### Blueprints

Creating blueprints is made super easy here. You only need to create you blueprint in a package under
`blueprints` package and do any one of the following-

1. Make a `create_blueprint` factory function in `__init__.py` or expose it somehow from your blueprint package which will return a `tupple` like `(blueprint_instance, url_prefix)`. You blueprints will be auto registered when the application starts up.
2. Make two variables names `__blueprint__` and `__prefix__` in `__init__.py` or expose them somehow from your blueprint package and you are good to go.

### Database models

A declarative base class is ready and exposed to be used in `instance.db` as `Base` with proper naming conventions. This base class has the following attributes predefined -

1. `__tablename__` - this will be autogenerated using your model's class name. For example if your model class is `SomeModel`, the table name will be `some_model`. This is important to understand as you will need it to define `DOMAIN` schema for `Eve`.
2. `id` - Default is a `sqlalchemy.Integer` type primary key
3. `_created` - `sqlalchemy.DateTime` type. Needed for `Eve` application
4. `_updated` - `sqlalchemy.DateTime` type. Needed for `Eve` application
5. `_etag` - `sqlalchemy.Text` type. Needed for `Eve` application

Additionally a default `__repr__` method is implemented which will return `ModelClassName<Model_id>` string.

You can override any of these to better suite your need, but attributes 3-5 are required for `Eve` application schema, so don't chamge them unless you know what you are doing.

All database models will be auto imported at application startup. You can control the scanning procedure
by modifying the following configurations-

1. `MODEL_DIRS` - A list of directory names (only the directory name not absolute path) to look for models.
2. `MODEL_EXCLUDE_FILES` - A list of file names (python files like `__init__.py`) to exclude from importing.

All the modules available inside the `MODEL_DIRS` excluding the modules in `MODEL_EXCLUDE_FILES` will be imported. So define your models in those modules.

### Eve DOMAIN Schema

This was particularly tricky because `Eve-SQLAlchemy` needs model classes to register resources. But it's made easy here. All you need is to know the table name of you models. Now you define the `DOMAIN` schema in
`instance.configs.schema.EVE_SCHEMA` list. Here every element is a `tupple` like this - `(table_name, dict(table_configurations))`. `table_configurations` are the configurations you use to define your schema for `Eve` application. The models will be registered with their configurations at application startup.

### Application configuration

Two separate modules are dedicated to define development and production release configuration.
For development configuration use `instance.configs.development.APP_CONFIG` dictionary and for 
production release use `instance.configs.production.APP_CONFIG` dictionary.

### Makefile

A convenient `Makefile` is prepared for you with the following commands -

1. `make` \ `make all`: Initialize alembic configs, migrate and upgrade and finally run the application in 
development mode.
2. `make initdb`: Initialize alembic configs and directories. You need to run this only once.
3. `make migrate`: Create migration
4. `make upgrade`: Upgrade database to latest migration
5. `make downgrade`: Downgrade one revision
6. `make run`: Run the application in  development mode
7. `make run_prod`: Run the application in production mode

The makefile is inside the application directory so you will need to open cmd or terminal inside the application directory.

### Switching run mode

Switching between development and production mode is done using an environmental variable
named `PROD`, just set `PROD=1` prior to running the application to run in production mode. Otherwise 
it will run in development mode. Database migration command will also be affected by this variable.

### Running Flask Shell

Flask shell is a convenient tool to test your app quickly. To run flask shell set environmental variable
`FLASK_APP` to `your_app_name.application` prior to run `flask shell` command. `PROD` variable is effective
here as well. Use it to switch configuration.

### Running tests

Write your tests subclassing `unittest.TestCase` and you are good to go. you can run tests in a number of 
ways -

1. `python setup.py test`
2. `make run_tests` from application directory
3. or specify particular module to run

### Notes

There is not default view or api or model created for you, I believe thats your field of expertise.
Using systemwide python installation or a virtualenv is also left upto your choice of development.

By default your REST api will be exposed under `api` prefix, feel free to change it to suite your need.

### Contribute

Any contribution or suggestion is welcome. Make an issue in github, or fork it to change if you want.

